#! /bin/bash -e
# Mimics addpkg behavior in git.
case `uname` in
  Darwin) ECHO=echo ;;
  *) ECHO="echo -e" ;;
esac
usage () {
  echo "git cms-addpkg [options] SubSystem/Package"
  echo "git cms-addpkg [options] -f FILE"
  echo
  echo "Options:"
  $ECHO "-h                 \tthis help message"
  $ECHO
  $ECHO "-d, --debug        \tenable debug output"
  $ECHO "-f, --file FILE    \tread the list of packages to be checkoed out from FILE"
  $ECHO "    --https        \tuse https, rather than ssh to access your personal repository"
  $ECHO "    --ssh          \tuse ssh, rather than https to access the official repository"
  $ECHO "-z, --quiet        \tdo not print out progress"
  $ECHO "-y, --yes          \tassume yes to all questions"
  exit $1
}

VERBOSE=1
INITOPTIONS=""                      # options passed to git cms-init
VERBOSE_STREAM=/dev/stderr
DEBUG_STREAM=/dev/null

verbose () {
  if [ "X$VERBOSE" = X1 ]; then
    echo "$@"
  fi
}

PKG_NAME=
CMSSW_TAG=
INPUT_FILE=
while [ "$#" != 0 ]; do
  case "$1" in
    -h | --help )
      usage 0;;
    -d | --debug )
      INITOPTIONS="$INITOPTIONS $1"
      shift; set -x; DEBUG_STREAM=/dev/stderr ;;
    -f | --file )
      OPTION=$1; shift
      INPUT_FILE="$1"; shift
      if [ ! "$INPUT_FILE" ]; then
        $ECHO "git cms-addpkg: option $OPTION requires an argument"
        $ECHO
        usage 1
      elif [ ! -r "$INPUT_FILE" ]; then
        $ECHO "git cms-addpkg: file $INPUT_FILE does not exist or is not readable"
        $ECHO
        usage 1
      fi
      unset OPTION
      ;;
    -q | --quiet )
      INITOPTIONS="$INITOPTIONS $1"
      shift; set +x; VERBOSE=0; VERBOSE_STREAM=/dev/null ;;
    -y | --yes )
      INITOPTIONS="$INITOPTIONS $1"
      shift; ASSUME_YES=1 ;;
    --https )
      INITOPTIONS="$INITOPTIONS $1"
      shift; USE_HTTPS_ACCESS_METHOD=true ;;
    --ssh )
      INITOPTIONS="$INITOPTIONS $1"
      shift; USE_SSH_ACCESS_METHOD=true ;;
    -*)
      echo Unknown option $1 ; usage 1 ;;
    *)
      if [ "$INPUT_FILE" == "" ]; then
        # check out a single package
        if [ "X$PKG_NAME" = X ]; then
          PKG_NAME=$1
        elif [ "X$CMSSW_TAG" = X ]; then
          CMSSW_TAG=$1
        else
          echo "git cms-addpkg: you can specify only one package at the time." ; exit 1
        fi
        shift 1
      else
        # check out a list of packages via -f / --file FILE
        if [ "X$CMSSW_TAG" = X ]; then
          CMSSW_TAG=$1
        else
          echo "git cms-addpkg: you cannot specify a package and input from file at the same time." ; exit 1
        fi
      fi
    ;;
  esac
done

if [ "$PKG_NAME" == "" ] && [ "$INPUT_FILE" == "" ] ; then
  echo "You need to specify at least one package or input file." ; exit 1
fi

GITHUB_USERNAME="`git config --global --get user.github || true`"
if [ "X$GITHUB_USERNAME" = X ]; then
  echo "Cannot find your GitHub information."
  echo "Please register at"
  echo
  echo "https://github.com"
  echo
  echo "and then configure git via:"
  echo
  echo "git config --global user.github <your github username>"
  exit 1
fi
USER_FULLNAME="`git config --global --get user.name || true`"
if [ "X$USER_FULLNAME" = X ]; then
  echo "Cannot find your name in git configuration."
  echo "Please set it up via:"
  echo
  echo "git config --global user.name <your name> <your last name>"
  exit 1
fi
USER_EMAIL="`git config --global --get user.email || true`"
if [ "X$USER_EMAIL" = X ]; then
  echo "Cannot find your email in git configuration."
  echo "Please set it up via:"
  echo
  echo "git config --global user.email <your e-mail>"
  exit 1
fi


if [ "X$CMSSW_BASE" = X ]; then
  if [ "X$CMSSW_TAG" = X ]; then
    verbose CMSSW environment not setup. Do cmsenv in some workarea or specify tag to checkout.
    exit 1
  else
    verbose Warning CMSSW environment not found. Checking out packages in $PWD/src.
    CMSSW_BASE=$PWD
  fi
fi

if [ "X$CMSSW_TAG" = X ]; then
  verbose No release tags specified, using default $CMSSW_VERSION.
  CMSSW_TAG=$CMSSW_VERSION
fi

CMSSW_BASE_BRANCH=`echo $CMSSW_TAG | sed -e 's/\(CMSSW_[0-9][0-9]*_[0-9][0-9]*\).*/\1/'`

# SLHC releases
case $CMSSW_TAG in
  *_SLHC*)
    SLHC=_SLHC ;;
esac

# This is not the case at FNAL. Disabling it for now.
#IN_RELEASE=`echo $PWD | grep -q -e "^$CMSSW_BASE" 2> /dev/null && echo 1 || echo 0`
#if [ "X$IN_RELEASE" = X0 ]; then
#  OLD_CMSSW_BASE=$CMSSW_BASE
#  eval `scram run -sh` >/dev/null
#  IN_RELEASE=`echo $PWD | grep -q -e "^$CMSSW_BASE" 2> /dev/null && echo 1 || echo 0`
#  if [ "X$IN_RELEASE" = X0 ]; then
#    echo git cms-addpkg must be run from inside a CMSSW area.
#    exit 1
#  else
#    echo git cms-addpkg: You have currently set up the environment of $OLD_CMSSW_BASE, however you are running inside $CMSSW_BASE.
#    echo Please go inside $OLD_CMSSW_BASE, or use cmsenv to switch to $CMSSW_BASE.
#    exit 1
#  fi
#fi

case `git --version` in
  git\ version\ 1.7*)
    OFFICIAL_CMSSW_REPO=git@github.com:cms-sw/cmssw.git
    USER_CMSSW_REPO=git@github.com:$GITHUB_USERNAME/cmssw.git
    # git 1.7.x does not support a leading slash in /gitignore and .git/info/sparse-checkout
    LEADING_SLASH=
  ;;
  *)
    if [ "X$USE_SSH_ACCESS_METHOD" = X ]; then
      OFFICIAL_CMSSW_REPO=https://github.com/cms-sw/cmssw.git
    else
      OFFICIAL_CMSSW_REPO=git@github.com:cms-sw/cmssw.git
    fi
    if [ "X$USE_HTTPS_ACCESS_METHOD" = X ]; then
      USER_CMSSW_REPO=git@github.com:$GITHUB_USERNAME/cmssw.git
    else
      USER_CMSSW_REPO=https://github.com/$GITHUB_USERNAME/cmssw.git
    fi
    LEADING_SLASH=/
  ;;
esac

if [ "X$CMSSW_GIT_REFERENCE" = X ]; then
  case `hostname -f` in
    *.cern.ch)
      if [ -e /afs/cern.ch/cms/git-cmssw-mirror/cmssw.git ]; then
        CMSSW_GIT_REFERENCE=/afs/cern.ch/cms/git-cmssw-mirror/cmssw.git
      else
        CMSSW_GIT_REFERENCE=~/.cmsgit-cache
      fi
    ;;
    *) CMSSW_GIT_REFERENCE=~/.cmsgit-cache ;;
  esac
fi

if [ ! -e $CMSSW_GIT_REFERENCE ]; then
  while [ X$QUESTION_DONE = X ]; do
    if [ X$ASSUME_YES = X ]; then
      read -n 1 -p "Your reference git repository does not seem to exist, would you like to create it? [ y / N / ? ] "
      QUESTION_DONE=1
    else
      REPLY=y
      QUESTION_DONE=1
    fi
    case $REPLY in
      y|Y|yes|YES)
        git clone --bare $OFFICIAL_CMSSW_REPO $CMSSW_GIT_REFERENCE
        touch $CMSSW_GIT_REFERENCE/create-`whoami`
      ;;
      [?])
        echo
        echo Answering yes will create a new cache directory in \$CMSSW_GIT_REFERENCE:
        echo
        echo i.e. $CMSSW_GIT_REFERENCE
        echo
        echo and put there a copy of the official CMSSW repository. git cms-addpkg will then
        echo reuse this information to keep your CMSSW workareas to a minimal size.
        echo The initial checkout could take a few minutes, but all the others should then
        echo take only a few seconds.
        echo
        echo Just say yes.
        echo
        QUESTION_DONE=
      ;;
      *)
        CMSSW_GIT_REFERENCE=none
      ;;
    esac
  done
fi

if [ -e $CMSSW_GIT_REFERENCE/create-`whoami` ]; then
  (cd $CMSSW_GIT_REFERENCE ;  git remote update origin 2>$VERBOSE_STREAM >$VERBOSE_STREAM)
fi

mkdir -p $CMSSW_BASE/src
cd $CMSSW_BASE/src

if [ ! -d "$CMSSW_BASE/src/.git" ]; then
  # initialize the local repository
  git cms-init $INITOPTIONS $CMSSW_TAG
else
  verbose You are on branch ${CMSSW_BASE_BRANCH}_X$SLHC
  # refresh the local repository
  [ -n "$CMSSW_MIRROR" ] && git remote set-url official-cmssw $CMSSW_MIRROR
  git fetch official-cmssw        2> $VERBOSE_STREAM
  git fetch official-cmssw --tags 2> $VERBOSE_STREAM
  [ -n "$CMSSW_MIRROR" ] && git remote set-url official-cmssw $OFFICIAL_CMSSW_REPO
fi

if [ "$INPUT_FILE" ]; then
  verbose "Checking out packages in tag $CMSSW_TAG:"
  verbose "$(< "$INPUT_FILE")"

  # FIXME check the syntax of the input file ?

  # add the requested package(s) to the sparse checkout
  cp -f $CMSSW_BASE/src/.git/info/sparse-checkout $CMSSW_BASE/src/.git/info/sparse-checkout-new
  cat "$INPUT_FILE" | sed -e "s|[/]*$|/|;s|^/*|${LEADING_SLASH}|" >> $CMSSW_BASE/src/.git/info/sparse-checkout-new
  cat .git/info/sparse-checkout-new | sort -u > $CMSSW_BASE/src/.git/info/sparse-checkout
  rm -f .git/info/sparse-checkout-new
else
  verbose "Checking out $PKG_NAME in tag $CMSSW_TAG."

  # add the requested package(s) to the sparse checkout
  cp -f $CMSSW_BASE/src/.git/info/sparse-checkout $CMSSW_BASE/src/.git/info/sparse-checkout-new
  echo "$PKG_NAME" | sed -e "s|[/]*$|/|;s|^/*|${LEADING_SLASH}|" >> $CMSSW_BASE/src/.git/info/sparse-checkout-new
  cat .git/info/sparse-checkout-new | sort -u > $CMSSW_BASE/src/.git/info/sparse-checkout
  rm -f .git/info/sparse-checkout-new
fi

#cd $CMSSW_BASE/src
#if [ "X`git show-ref $CMSSW_TAG || true`"  = X ]; then
#  echo "Unknown tag $CMSSW_TAG."
#  if [ "X$VERBOSE" = X1 ]; then
#    echo "Similar known tags in the repository are:"
#    git tag | grep $CMSSW_BASE_BRANCH
#  fi
#  exit 1
#fi
#
#if [ "X`git symbolic-ref fork-point 2>$DEBUG_STREAM || true`" = X ]; then
#  git reset --hard ${CMSSW_TAG} >$DEBUG_STREAM
#  git checkout -b from-$CMSSW_TAG official-cmssw/${CMSSW_BASE_BRANCH}_X$SLHC
#  git symbolic-ref fork-point $CMSSW_TAG
#  git reset --hard $CMSSW_TAG
#  git branch --set-upstream from-$CMSSW_TAG official-cmssw/${CMSSW_BASE_BRANCH}_X$SLHC 2>$DEBUG_STREAM >$DEBUG_STREAM || git branch --set-upstream-to=official-cmssw/${CMSSW_BASE_BRANCH}_X$SLHC from-$CMSSW_TAG 2>$DEBUG_STREAM >$DEBUG_STREAM
#fi
#
#if [ ! "X`git symbolic-ref fork-point 2>/dev/null || true`" = "X$CMSSW_TAG" ]; then
#  verbose "This operation will merge in your area a $CMSSW_TAG."
#  if [ ! X$FORCE = X1 ]; then
#    verbose "Denying operation. Use -f, --force to force it, conflicts might occur."
#    exit 1
#  fi
#fi

git read-tree -mu HEAD
case $PKG_NAME in
  *[*]* )
  ;;
  *)
    if [ ! -d "$CMSSW_BASE/src/$PKG_NAME" ]; then
      echo "git cms-addpkg: package $PKG_NAME does not exist in tag $CMSSW_TAG."
      exit 1
    fi
  ;;
esac
