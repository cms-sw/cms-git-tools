#!/bin/sh -e
# Mimics addpkg behavior in git.
case `uname` in 
  Darwin) ECHO=echo ;;
  *) ECHO="echo -e" ;;
esac
usage () {
  echo "git cms-addpkg [options] SubSystem/Package"
  echo
  echo "Options:"
  $ECHO "-h                 \tthis help message"
  $ECHO
  $ECHO "-d, --debug        \tenable debug output"
  $ECHO "-f, --force        \tforce dangerous operations"
  $ECHO "    --https        \tuse https, rather than ssh to access your personal repository"
  $ECHO "-z, --quiet        \tdo not print out progress"
  $ECHO "-y, --yes          \tassume yes to all questions"
  exit $1
}

VERBOSE=1
FORCE=0
VERBOSE_STREAM=/dev/stderr
DEBUG_STREAM=/dev/null

verbose () {
  if [ "X$VERBOSE" = X1 ]; then
    echo "$@"
  fi
}

PKG_NAME=
CMSSW_TAG=
while [ "$#" != 0 ]; do
  case "$1" in
    -h | --help )
      usage 0;;
    -d | --debug )
      shift; set -x; DEBUG_STREAM=/dev/stderr ;;
    -q | --quiet )
      shift; set +x; VERBOSE=0; VERBOSE_STREAM=/dev/null ;;
    -y | --yes )
      shift; ASSUME_YES=1 ;;
    -f | --force )
      shift; set +x; FORCE=1 ;;
    --https )
      shift; USE_HTTPS_ACCESS_METHOD=true ;;
    -*)
      echo Unknown option $1 ; usage 1 ;;
    *)
      if [ "X$PKG_NAME" = X ]; then
        PKG_NAME=$1
      elif [ "X$CMSSW_TAG" = X ]; then
        CMSSW_TAG=$1
      else
        echo "You can specify only one package at the time." ; exit 1
      fi
      shift 1
    ;;
  esac
done

GITHUB_USERNAME="`git config --global --get user.github || true`"
if [ "X$GITHUB_USERNAME" = X ]; then
  echo "Cannot find your GitHub information."
  echo "Please register at"
  echo
  echo "https://github.com"
  echo
  echo "and then configure git via:"
  echo
  echo "git config --global user.github <your github username>"
  exit 1
fi
USER_FULLNAME="`git config --global --get user.name || true`"
if [ "X$USER_FULLNAME" = X ]; then
  echo "Cannot find your name in git configuration."
  echo "Please set it up via:"
  echo
  echo "git config --global user.name <your name> <your last name>"
  exit 1
fi
USER_EMAIL="`git config --global --get user.email || true`"
if [ "X$USER_EMAIL" = X ]; then
  echo "Cannot find your email in git configuration."
  echo "Please set it up via:"
  echo
  echo "git config --global user.email <your e-mail>"
  exit 1
fi


if [ "X$PKG_NAME" = X ]; then
  echo "You need to specify at least one package." ; exit 1 
fi

if [ "X$CMSSW_BASE" = X ]; then
  if [ "X$CMSSW_TAG" = X ]; then
    verbose CMSSW environment not setup. Do cmsenv in some workarea or specify tag to checkout.
    exit 1
  else
    verbose Warning CMSSW environment not found. Checking out packages in $PWD/src.
    CMSSW_BASE=$PWD
  fi
fi

if [ "X$CMSSW_TAG" = X ]; then
  verbose No release tags specified, using default $CMSSW_VERSION.
  CMSSW_TAG=$CMSSW_VERSION
fi


CMSSW_BASE_BRANCH=`echo $CMSSW_TAG | sed -e 's/\(CMSSW_[0-9][0-9]*_[0-9][0-9]*\).*/\1/'`

verbose You are on branch ${CMSSW_BASE_BRANCH}_X
verbose Checking out $PKG_NAME in tag $CMSSW_TAG.

# This is not the case at FNAL. Disabling it for now.
#IN_RELEASE=`echo $PWD | grep -q -e "^$CMSSW_BASE" 2> /dev/null && echo 1 || echo 0`
#if [ "X$IN_RELEASE" = X0 ]; then
#  OLD_CMSSW_BASE=$CMSSW_BASE
#  eval `scram run -sh` >/dev/null
#  IN_RELEASE=`echo $PWD | grep -q -e "^$CMSSW_BASE" 2> /dev/null && echo 1 || echo 0`
#  if [ "X$IN_RELEASE" = X0 ]; then
#    echo git cms-addpkg must be run from inside a CMSSW area.
#    exit 1
#  else
#    echo Error: You have currently set up the environment of $OLD_CMSSW_BASE, however you are running inside $CMSSW_BASE.
#    echo Please go inside $OLD_CMSSW_BASE, or use cmsenv to switch to $CMSSW_BASE.
#    exit 1
#  fi
#fi

case `git --version` in 
  git\ version\ 1.7*)
    OFFICIAL_CMSSW_REPO=git@github.com:cms-sw/cmssw.git ;;
  *)
    OFFICIAL_CMSSW_REPO=https://github.com/cms-sw/cmssw.git ;;
esac


if [ "X$CMSSW_GIT_REFERENCE" = X ]; then
  case `hostname -f` in
    *.cern.ch)
      if [ -e /afs/cern.ch/cms/git-cmssw-mirror/cmssw.git ]; then
        CMSSW_GIT_REFERENCE=/afs/cern.ch/cms/git-cmssw-mirror/cmssw.git
      else
        CMSSW_GIT_REFERENCE=~/.cmsgit-cache
      fi
    ;;
    *) CMSSW_GIT_REFERENCE=~/.cmsgit-cache ;;
  esac
fi

if [ ! -e $CMSSW_GIT_REFERENCE ]; then
  while [ X$QUESTION_DONE = X ]; do
    if [ X$ASSUME_YES = X ]; then
      read -n 1 -p "Your reference git repository does not seem to exist, would you like to create it? [ y / N / ? ] "
      QUESTION_DONE=1
    else
      REPLY=y
      QUESTION_DONE=1
    fi
    case $REPLY in
      y|Y|yes|YES)
        git clone --bare https://github.com/cms-sw/cmssw.git $CMSSW_GIT_REFERENCE
        touch $CMSSW_GIT_REFERENCE/create-`whoami`
      ;;
      [?])
        echo
        echo Answering yes will create a new cache directory in \$CMSSW_GIT_REFERENCE:
        echo
        echo i.e. $CMSSW_GIT_REFERENCE
        echo
        echo and put there a copy of the official CMSSW repository. git cms-addpkg will then
        echo reuse this information to keep your CMSSW workareas to a minimal size.
        echo The initial checkout could take a few minutes, but all the others should then
        echo take only a few seconds.
        echo
        echo Just say yes.
        echo
        QUESTION_DONE=
      ;;
      *)
        CMSSW_GIT_REFERENCE=none
      ;;
    esac
  done
fi

if [ -e $CMSSW_GIT_REFERENCE/create-`whoami` ]; then
  (cd $CMSSW_GIT_REFERENCE ;  git remote update origin 2>$VERBOSE_STREAM >$VERBOSE_STREAM)
fi

mkdir -p $CMSSW_BASE/src
cd $CMSSW_BASE/src
if [ ! -d "$CMSSW_BASE/src/.git" ]; then
  git clone -n --reference $CMSSW_GIT_REFERENCE $OFFICIAL_CMSSW_REPO $CMSSW_BASE/src
  git remote rename origin official-cmssw
  git fetch official-cmssw --tags
  if [ "X$USE_HTTPS_ACCESS_METHOD" = X ]; then
    git config remote.my-cmssw.url git@github.com:$GITHUB_USERNAME/cmssw.git
  else
    git config remote.my-cmssw.url https://github.com/$GITHUB_USERNAME/cmssw.git
  fi
fi
git config --get-all remote.official-cmssw.fetch | grep "refs/remotes/official-cmssw/*" >$DEBUG_STREAM || git config remote.official-cmssw.fetch "+refs/heads/*:refs/remotes/official-cmssw/*"
git config core.sparsecheckout true
touch $CMSSW_BASE/src/.git/info/sparse-checkout
cp -f $CMSSW_BASE/src/.git/info/sparse-checkout $CMSSW_BASE/src/.git/info/sparse-checkout-new
echo "$PKG_NAME" | sed -e 's|[/]*$|/|;s|^/*|/|' >> $CMSSW_BASE/src/.git/info/sparse-checkout-new
cat .git/info/sparse-checkout-new | sort -u > $CMSSW_BASE/src/.git/info/sparse-checkout
# If the tag does not exists, we fetch it.
if [ ! -e $CMSSW_BASE/src/.git/refs/tags/$CMSSW_TAG ]; then
  if [ ! "X$CMSSW_MIRROR" = X ]; then
    git remote set-url official-cmssw $CMSSW_MIRROR
    git fetch --tags $CMSSW_MIRROR >$VERBOSE_STREAM
    git remote set-url official-cmssw https://github.com/cms-sw/cmssw.git
  fi
fi

if [ ! -d $CMSSW_BASE/src/.git/refs/remotes/official-cmssw ]; then
  git fetch official-cmssw 2> $VERBOSE_STREAM
  git fetch --tags official-cmssw 2> $VERBOSE_STREAM
fi

cd $CMSSW_BASE/src
if [ "X`git show-ref $CMSSW_TAG || true`"  = X ]; then
  echo "Unknown tag $CMSSW_TAG."
  if [ "X$VERBOSE" = X1 ]; then
    echo "Similar known tags in the repository are:"
    git tag | grep $CMSSW_BASE_BRANCH
  fi
  exit 1
fi

if [ "X`git symbolic-ref fork-point 2>$DEBUG_STREAM || true`" = X ]; then
  git reset --hard ${CMSSW_TAG} >$DEBUG_STREAM
  git checkout -b from-$CMSSW_TAG official-cmssw/${CMSSW_BASE_BRANCH}_X
  git symbolic-ref fork-point $CMSSW_TAG
  git reset --hard $CMSSW_TAG
  git branch --set-upstream from-$CMSSW_TAG official-cmssw/${CMSSW_BASE_BRANCH}_X 2>$DEBUG_STREAM >$DEBUG_STREAM || git branch --set-upstream-to=official-cmssw/${CMSSW_BASE_BRANCH}_X from-$CMSSW_TAG 2>$DEBUG_STREAM >$DEBUG_STREAM
fi

if [ ! "X`git symbolic-ref fork-point 2>/dev/null || true`" = "X$CMSSW_TAG" ]; then
  verbose "This operation will merge in your area a $CMSSW_TAG."
  if [ ! X$FORCE = X1 ]; then
    verbose "Denying operation. Use -f, --force to force it, conflicts might occur."
    exit 1
  fi
fi

git read-tree -mu HEAD
case $PKG_NAME in 
  *[*]* )
  ;;
  *)
    if [ ! -d "$CMSSW_BASE/src/$PKG_NAME" ]; then
      echo "Error: package $PKG_NAME does not exist in tag $CMSSW_TAG."
      exit 1
    fi
  ;;
esac
