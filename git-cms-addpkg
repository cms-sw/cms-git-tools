#!/bin/sh -e
# Mimics addpkg behavior in git.
usage () {
  echo "git cms-addpkg [options] SubSystem/Package"
  echo
  echo "Options:"
  echo -e "-h                 \tthis help message"
  echo -e "-d, --debug        \tenable debug output"
  echo -e "-q, --quiet        \tdo not print out progress"
  echo -e "-f, --force        \tforce dangerous operations"
  echo -e "-y, --yes          \tassume yes to all questions"
  exit $1
}

VERBOSE=1
FORCE=0
VERBOSE_STREAM=/dev/stderr

verbose () {
  if [ "X$VERBOSE" = X1 ]; then
    echo "$@"
  fi
}

PKG_NAME=
CMSSW_TAG=
while [ "$#" != 0 ]; do
  case "$1" in
    -h | --help )
      usage 0;;
    -d | --debug )
      shift; set -x ;;
    -q | --quiet )
      shift; set +x; VERBOSE=0; VERBOSE_STREAM=/dev/null ;;
    -y | --yes )
      shift; ASSUME_YES=1 ;;
    -f | --force )
      shift; set +x; FORCE=1 ;;
    -*)
      echo Unknown option $1 ; usage 1 ;;
    *)
      if [ "X$PKG_NAME" = X ]; then
        PKG_NAME=$1
      elif [ "X$CMSSW_TAG" = X ]; then
        CMSSW_TAG=$1
      else
        echo "You can specify only one package at the time." ; exit 1
      fi
      shift 1
    ;;
  esac
done

GITHUB_USERNAME="`git config --global --get cms.github.user || true`"
if [ "X$GITHUB_USERNAME" = X ]; then
  echo "Cannot find your GitHub information."
  echo "Please register at"
  echo
  echo "https://github.com"
  echo
  echo "and provide your username."
  echo
  GITHUB_USERNAME=
  while [ "X$GITHUB_USERNAME" = X ]; do 
    read -p "What is your github username? "
    GITHUB_USERNAME=`echo $REPLY | sed -e 's/[ \t]*//g'`
    # It is intended to not have "" around $GITHUB_USERNAME
    if [ "X$GITHUB_USERNAME" = X ]; then
      echo "You provided an empty string."
    fi
  done
  echo
  echo "Hello, $GITHUB_USERNAME, I will remember you on this computer now."
  echo
  echo "At any time you can change your information by doing."
  echo
  echo "git config --global cms.github.user $GITHUB_USERNAME"
  git config --global cms.github.user $GITHUB_USERNAME
fi

if [ "X$CMSSW_BASE" = X ]; then
  echo CMSSW environment not setup. Do cmsenv in some workarea.
  exit 1
fi

if [ "X$PKG_NAME" = X ]; then
  echo "You need to specify at least one package." ; exit 1 
fi

if [ "X$CMSSW_TAG" = X ]; then
  verbose No release tags specified, using default $CMSSW_VERSION.
  CMSSW_TAG=$CMSSW_VERSION
fi

CMSSW_BASE_BRANCH=`echo $CMSSW_VERSION | sed -e 's/\(CMSSW_[0-9][0-9]*_[0-9][0-9]*\).*/\1/'`

verbose You are on branch ${CMSSW_BASE_BRANCH}_X
verbose Checking out $PKG_NAME in tag $CMSSW_TAG.

# This is not the case at FNAL. Disabling it for now.
#IN_RELEASE=`echo $PWD | grep -q -e "^$CMSSW_BASE" 2> /dev/null && echo 1 || echo 0`
#if [ "X$IN_RELEASE" = X0 ]; then
#  OLD_CMSSW_BASE=$CMSSW_BASE
#  eval `scram run -sh` >/dev/null
#  IN_RELEASE=`echo $PWD | grep -q -e "^$CMSSW_BASE" 2> /dev/null && echo 1 || echo 0`
#  if [ "X$IN_RELEASE" = X0 ]; then
#    echo git cms-addpkg must be run from inside a CMSSW area.
#    exit 1
#  else
#    echo Error: You have currently set up the environment of $OLD_CMSSW_BASE, however you are running inside $CMSSW_BASE.
#    echo Please go inside $OLD_CMSSW_BASE, or use cmsenv to switch to $CMSSW_BASE.
#    exit 1
#  fi
#fi

if [ "X$CMSSW_GIT_REFERENCE" = X ]; then
  case `hostname` in
    *.cern.ch)
      if [ -e /afs/cern.ch/cms/git-cmssw-mirror/cmssw.git ]; then
        CMSSW_GIT_REFERENCE=/afs/cern.ch/cms/git-cmssw-mirror/cmssw.git
      else
        CMSSW_GIT_REFERENCE=~/.cmsgit-cache
      fi
    ;;
    *) CMSSW_GIT_REFERENCE=~/.cmsgit-cache ;;
  esac
fi

if [ ! -e $CMSSW_GIT_REFERENCE ]; then
  while [ X$QUESTION_DONE = X ]; do
    if [ X$ASSUME_YES = X ]; then
      read -n 1 -p "Your reference git repository does not seem to exist, would you like to create it? [ y / N / ? ] "
      QUESTION_DONE=1
    else
      REPLY=y
      QUESTION_DONE=1
    fi
    case $REPLY in
      y|Y|yes|YES)
        git clone --bare https://github.com/cms-sw/cmssw.git $CMSSW_GIT_REFERENCE
        touch $CMSSW_GIT_REFERENCE/create-`whoami`
      ;;
      [?])
        echo
        echo Answering yes will create a new cache directory in \$CMSSW_GIT_REFERENCE:
        echo
        echo i.e. $CMSSW_GIT_REFERENCE
        echo
        echo and put there a copy of the official CMSSW repository. git-cms-addpkg will then
        echo reuse this information to keep your CMSSW workareas to a minimal size.
        echo The initial checkout could take a few minutes, but all the others should then
        echo take only a few seconds.
        echo
        echo Just say yes.
        echo
        QUESTION_DONE=
      ;;
      *)
        CMSSW_GIT_REFERENCE=none
      ;;
    esac
  done
fi

if [ -e $CMSSW_GIT_REFERENCE/create-`whoami` ]; then
  (cd $CMSSW_GIT_REFERENCE ;  git remote update origin 2> $VERBOSE_STREAM)
fi

mkdir -p $CMSSW_BASE/src
cd $CMSSW_BASE/src
if [ ! -d "$CMSSW_BASE/src/.git" ]; then
  git init
  git config --local --bool core.sparsecheckout true
  git config --local --bool core.bare false
  git config remote.my-cmssw.url https://github.com/$GITHUB_USERNAME/cmssw.git
  touch $CMSSW_BASE/src/.git/info/sparse-checkout
  # If we have a reference repository, use it by copying locally all the files.
  if [ ! "X$CMSSW_GIT_REFERENCE" = Xnone ]; then
    echo $CMSSW_GIT_REFERENCE/objects > $CMSSW_BASE/src/.git/objects/info/alternates
  fi
fi
git config remote.cms-official.url https://github.com/cms-sw/cmssw.git
git config --get-all remote.cms-official.fetch | grep "refs/remotes/cms-official/*" >/dev/null || git config remote.cms-official.fetch "+refs/heads/*:refs/remotes/cms-official/*"
git config core.sparsecheckout true
touch $CMSSW_BASE/src/.git/info/sparse-checkout
cp -f $CMSSW_BASE/src/.git/info/sparse-checkout $CMSSW_BASE/src/.git/info/sparse-checkout-new
echo "$PKG_NAME" | sed -e 's|[/]*$|/|;s|^/*|/|' >> $CMSSW_BASE/src/.git/info/sparse-checkout-new
cat .git/info/sparse-checkout-new | sort -u > $CMSSW_BASE/src/.git/info/sparse-checkout
# If the tag does not exists, we fetch it.
if [ ! -e $CMSSW_BASE/src/.git/refs/tags/$CMSSW_TAG ]; then
  if [ ! "X$CMSSW_MIRROR" = X ]; then
    git remote set-url cms-official $CMSSW_MIRROR
    git fetch --tags $CMSSW_MIRROR
    git remote set-url cms-official https://github.com/cms-sw/cmssw.git
  fi
fi

if [ ! -d $CMSSW_BASE/src/.git/refs/remotes/cms-official ]; then
  git fetch cms-official 2> $VERBOSE_STREAM
  git fetch --tags cms-official 2> $VERBOSE_STREAM
fi

if [ ! "X`git show-ref $CMSSW_TAG || true`"  = X ]; then
  echo "Unknown tag $CMSSW_TAG."
  if [ "X$VERBOSE" = X1 ]; then
    echo "Similar known tags in the repository are:"
    git tag | grep $CMSSW_BASE_BRANCH
  fi
  exit 1
fi

if [ ! -e $CMSSW_BASE/src/.git/cms-base-tag ]; then
  git reset --hard $CMSSW_TAG >/dev/null
  git checkout ${CMSSW_BASE_BRANCH}_X
  git branch --set-upstream ${CMSSW_BASE_BRANCH}_X cms-official/${CMSSW_BASE_BRANCH}_X || true
  git reset --hard $CMSSW_TAG
  echo $CMSSW_TAG > $CMSSW_BASE/src/.git/cms-base-tag
fi
if [ ! "X`cat $CMSSW_BASE/src/.git/cms-base-tag`" = X$CMSSW_TAG ]; then
  verbose "This operation will merge in your area a vanilla $CMSSW_TAG."
  if [ ! X$FORCE = X1 ]; then
    verbose "Denying operation. Use -f, --force to force it, conflicts might occur."
    exit 1
  fi
fi

git read-tree -mu $CMSSW_TAG
if [ ! -d $CMSSW_BASE/src/$PKG_NAME ]; then
  echo "Error: package $PKG_NAME does not exist in tag $CMSSW_TAG."
  exit 1
fi
